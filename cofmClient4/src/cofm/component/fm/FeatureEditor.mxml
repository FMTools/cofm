<?xml version="1.0" encoding="utf-8"?>
<s:SkinnableContainer xmlns:fx="http://ns.adobe.com/mxml/2009" 
					  xmlns:s="library://ns.adobe.com/flex/spark" 
					  xmlns:mx="library://ns.adobe.com/flex/mx"
					  implements="cofm.model.IOperationListener"
					  creationComplete="initView();">
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	
	<fx:Script>
		<![CDATA[
			import cofm.command.*;
			import cofm.event.*;
			import cofm.model.*;
			import cofm.util.*;
			
			import spark.components.NavigatorContent;
			
			private static const BASIC_INFO_KEY: String = "__basic_info_tab__";
			
			private var tabMap: Dictionary = new Dictionary();
			
			private var featureXml: XML;
			private var featureId: int;
			
			private function initView(): void {
				FeatureModel.instance().registerSubView(this);
				ClientEvtDispatcher.instance().addEventListener(
					FeatureSelectEvent.FEATURE_SELECTED, onSelect);
				ClientEvtDispatcher.instance().addEventListener(
					ClientEvent.CURRENT_FEATURE_DELETED, onDelete);
				ClientEvtDispatcher.instance().addEventListener(
					ClientEvent.BASIC_INFO_UPDATED, onBasicInfoUpdated);
			}
			
			private function onSelect(evt: FeatureSelectEvent): void {
				if (this.featureId == evt.id) {
					// Prevent repeatly refresh
					return;
				}
				this.featureId = evt.id;
				this.reloadAllTabs();
			}
			
			private function onDelete(evt: ClientEvent): void {
				this.featureId = -1;
			}
			
			private function onBasicInfoUpdated(evt: ClientEvent): void {
				var basicInfo: Object = this.tabMap[BASIC_INFO_KEY];
				if (basicInfo != null) {
					FeatureBasicInfo(basicInfo).updateBasicInfo();
				}
			}
			
			private function reloadAllTabs(): void {
				tabNav.removeAllChildren();
				this.tabMap = new Dictionary();
				
				// Get the xml of current feature.
				var fs: XMLList = FeatureModel.instance().features.source.(@id==String(this.featureId));
				if (fs.length() <= 0) {
					return;
				}
				this.featureXml = fs[0];
				
				// Insert the Basic_info_tab first
				var basic: FeatureBasicInfo = new FeatureBasicInfo();
				basic.width = Size.EDITOR_W;
				basic.height = Size.EDITOR_H;
				var tabWrapper: NavigatorContent = new NavigatorContent();
				tabWrapper.addElement(basic);
				tabWrapper.label = RS.m_fe_basic_tab;
				basic.updateBasicInfo();
				this.tabNav.addChild(tabWrapper);
				this.tabMap[BASIC_INFO_KEY] = basic;
				
				// Add name, description and optionality
				addTab(FeatureModel.instance().attrs.source.(@name==Cst.ATTR_FEATURE_NAME)[0]);
				addTab(FeatureModel.instance().attrs.source.(@name==Cst.ATTR_FEATURE_DES)[0]);	
				addTab(FeatureModel.instance().attrs.source.(@name==Cst.ATTR_FEATURE_OPT)[0]);
				
				//TODO: Add refinement and binary constraints
				/*var refine: RefinementTab = new RefinementTab();
				refine.label = RS.EDIT_TAB_REFINE;
				setTabSize(refine);
				infoTab.addChild(refine);
				
				var cons: BinConstraintTab = new BinConstraintTab();
				cons.label = RS.EDIT_TAB_CONS;
				setTabSize(cons);
				infoTab.addChild(cons);
				*/
				
				// Add other tabs
				for each (var attr: Object in FeatureModel.instance().attrs.source) {
					if (attr.@name == Cst.ATTR_FEATURE_DES ||
						attr.@name == Cst.ATTR_FEATURE_NAME ||
						attr.@name == Cst.ATTR_FEATURE_OPT) {
						continue;
					}
					
					addTab(attr);
				}
			}
			
			// 
			private function addTab(attrSetItem: Object): void {
				// Get the attribute item in current feature, if there's no such 
				// item in current feature, then add tab according to the attrSetItem
				var attr: XML;
				var a: XMLList = featureXml.attrs.attr.(@name==String(attrSetItem.@name));
				if (a.length() > 0) {
					attr = a[0];
				} else {
					attr = XML(attrSetItem);
				}
				
				var tabWrapper: NavigatorContent = new NavigatorContent();
				var sheet: AttributeSheet = AttributeSheetFactory.createAttributeSheet(attr);
				tabWrapper.addElement(sheet);
				tabWrapper.label = sheet.attributeName
				this.tabNav.addChild(tabWrapper);
				// Manage this tab by the tabMap.
				this.tabMap[sheet.attributeName] = sheet; 
			}
			
			// IOperationListener methods
			public function handleVoteAddFeature(op: Object): void {
				// Only handles the removal of current feature
				if (op["featureId"] == String(this.featureId) &&
					op[FeatureModel.SHOULD_DELETE_ELEMENT] == true) {
					tabNav.removeAllChildren();
				}
			}
			
			public function handleVoteAddBinRel(op: Object): void{
				// Do nothing (the relationship tabs will update themselves.)
			}
			
			public function handleAddAttribute(op: Object): void {
				// Do nothing (only add tab when creating new values)
			}
			
			public function handleAddEnumAttribute(op: Object): void {
				// Do nothing
			}
			
			public function handleAddNumericAttribute(op: Object): void {
				// Do nothing
			}
			
			public function handleVoteAddValue(op: Object): void {
				if (op["featureId"] == String(this.featureId)) {
					var a: XMLList = 
						FeatureModel.instance().features.source.(@id==op["featureId"])..attr.(@name==op["attr"]);
					if (a.length() <= 0) {
						return;
					}
					
					// If the attribute tab hasn't been created...
					if (this.tabMap[String(op["attr"])] == null) {
						this.addTab(a[0]);
					} else {
						AttributeSheetFactory.setValuesForSheet(
							AttributeSheet(this.tabMap[String(op["attr"])]), a[0]);
					}
				}
			}
			
			public function handleInferVoteOnFeature(op: Object): void {
				// Do nothing (because only YES votes can be inferred, and this change can be updated in 
				// Basic Info Tab
			}
			
			public function handleInferVoteOnRelation(op: Object): void {
				// Do nothing (Changes will be reflected in relationship tabs)
			}
		]]>
	</fx:Script>
	
	<mx:TabNavigator id="tabNav" />
</s:SkinnableContainer>
