<?xml version="1.0" encoding="utf-8"?>
<s:TitleWindow xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx" width="660" height="580"
			   title="Add or change type definition"
			   xmlns:common="cofm.component.common.*"
			   close="onCancel();"
			   creationComplete="initView();">
	<s:layout>
		<s:VerticalLayout/>
	</s:layout>
	<s:states>
		<s:State name="EntityBegin" />
		<s:State name="TypeSelected" />
		<s:State name="AttrSelected" />
	</s:states>
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	
	<fx:Script>
		<![CDATA[
			import cofm.command.*;
			import cofm.event.*;
			import cofm.model.*;
			import cofm.util.*;
			
			import mx.collections.XMLListCollection;
			import mx.events.FlexEvent;
			import mx.events.ListEvent;
			import mx.managers.PopUpManager;
			
			private static const TO_BE_DELETED: String = "____TO_BE_DELETED____";
			private var typeId: int = 0;
			
			private var selectedTypeId: String;
			
			private static const nameAttrXml: XML = <attrDef name={Cst.ATTR_FEATURE_NAME} type={Cst.ATTR_TYPE_STRING} multi="true" dup="false"/>;
			private static const desAttrXml: XML = <attrDef name={Cst.ATTR_FEATURE_DES} type={Cst.ATTR_TYPE_TEXT} multi="true" dup="true"/>;
			
			[Bindable]
			public var entityTypes: XMLListCollection;
			
			[Bindable]
			public var typeTreeData: XMLListCollection;
			
			private function initView(): void {
				// Copy entity types from Model and generate into a tree.
				entityTypes = new XMLListCollection();
				typeTreeData = new XMLListCollection(new XMLList(<entype/>));
				for (var t: Object in Model.instance().entypes.source) {
					entityTypes.addItem(XML(t).copy());
					
					var rootType: XML = Model.instance().getRootType(XML(t));
					if (getNodeById(rootType.@id) == null) {
						var base: XML = rootNode();
						for (var curType: Object in Model.instance().getEntityTypeHierarchy(rootType.@id)) {
							var cur: XML = XML(curType).copy();
							// Remove the <attrDefs/> part from the <entype> node, otherwise
							// the <attrDefs/> will appear as a node in the tree.
							delete cur.attrDefs;
							base.appendChild(cur);
							base = cur;
						}
					}
				}
				
			}
			
			private function rootNode(): XML {
				return XML(typeTreeData.getItemAt(0));
			}
			
			private function getNodeById(id: String): XML {
				var nodes: XMLList = rootNode()..entype.(@id==id);
				if (nodes.length() > 0) {
					return XML(nodes[0]);
				}
				return null;
			}
			
			private function onTypeNameChanged(evt: ListEvent): void {
				// TODO: 1. store the old name when clicked the item.
				// 2. get the new name by item ID
				// 3. see if the name has been changed.
				trace ("+++ " + rootNode()..entype.(@id==selectedTypeId)[0].@name);
			}
			
			private function onTypeClicked(evt: ListEvent): void {
				this.currentState = "TypeSelected";	
				
				selectedTypeId = String(typeTree.selectedItem.@id);

				attrGrid.dataProvider = 
					entityTypes.source.(@id==selectedTypeId)[0].attrDefs.attrDef;
				
				attrForm.reset();
			}
			
			private function onNewType(): void {
				// Auto-generated temporary ID is equal or less than 0.
				var n: XML = <entype id={typeId--} name="Enter type name here"/>;
				rootNode().appendChild(n);
				typeTree.selectedItem = n;
				
				// Add the default attributes and copy to entityTypes.
				var c: XML = n.copy();
				c.appendChild(<attrDefs/>);
				c.attrDefs.appendChild(nameAttrXml.copy());
				c.attrDefs.appendChild(desAttrXml.copy());
				entityTypes.addItem(c);
			}
			
			private function onNewSubtype(): void {
				var parentType: XML = XML(entityTypes.source.(@id==selectedTypeId)[0]);
				var parentNode: XML = getNodeById(selectedTypeId);
				if (parentNode == null) {
					return;
				}
				
				var n: XML = <entype id={typeId--} superId={parentType.@id} name="Enter type name here"/>;
				parentNode.appendChild(n);
				typeTree.expandItem(parentNode, true);
				typeTree.selectedItem = n;
				
				// A subtype inherits all attributes from its parent.
				var type: XML = n.copy();
				type.attrDefs = parentType.attrDefs.copy();
				entityTypes.addItem(type);				
			}
			
			private function onAttributeClicked(): void {
				this.currentState = "AttrSelected";
				attrForm.attrXml = XML(attrGrid.selectedItem);
			}
			
			private function onAttributeChanged(): void {
				var cur: XML = attrForm.attrXml;
				if (this.currentState == "AttrSelected") {
					// Replace the selected attribute with the edited one.
					var old: XML = XML(attrGrid.selectedItem);
					old.@name = cur.@name;
					old.@type = cur.@type;
					old.@multi = cur.@multi;
					old.@dup = cur.@dup;
					old.setChildren(cur.children());
					
				} else {
					// Add the new attribute
					XML(entityTypes.source.(@id==selectedTypeId)[0]).appendChild(cur.copy());
					attrGrid.dataProvider = 
						entityTypes.source.(@id==selectedTypeId)[0].attrDefs.attrDef;
				}
				this.currentState = "TypeSelected";
				attrGrid.selectedIndex = -1;  // Make sure the attribute grid is not selected.
				attrForm.reset();
			}
		
			
			private function onCancel(): void {
				PopUpManager.removePopUp(this);
			}
			
			/*private function doCreateModel(): void {
				// Build the model information object for CreateModelCompositeCommand
				var etArray: Array = new Array();
				for each (var top: Object in this.etRoot().et) {
					buildEntypeHierarchy(XML(top), etArray);
				}
				
				var btArray: Array = new Array();
				for each (var binrel: Object in binRelations.source) {
					btArray.push({
						typeName: binrel.@name,
						sourceId: binrel.@left,
						targetId: binrel.@right,
						hier: binrel.@hier,
						dir: binrel.@dir
					});
				}
				
				// Build a refinement relation for each root entity type by default.
				for each (var rootType: Object in this.etRoot().et) {
					btArray.push({
						typeName: rootType.@name + "_" + Cst.BIN_REL_REFINES,
						sourceId: rootType.@id,
						targetId: rootType.@id,
						hier: true,
						dir: true
					});
				}
				
				var info: Object = {
					name: nameInput.text,
						description: introInput.text,
						entypes: etArray,
						bintypes: btArray
				};
				
				new CreateModelCompositeCommand(info).execute();
			}
			
			private function buildEntypeHierarchy(top: XML, dst: Array): void {
				var superId: int = -1;
				var entype: XML = top;
				do {
					dst.push(buildEntype(entype, superId));
					superId = int(entype.@id);
					entype = entype.et[0];
				} while (entype != null);
			}
			
			private function buildEntype(et: XML, superId: int): Object {
				var attrDefs: Array = new Array();
				var defs: XMLList = entityAttrs.source.(@id==String(et.@id));
				if (defs.length() > 0) {
					for each (var def: Object in defs[0].attr) {
						var d: Object = {
							name: def.@name,
								type: def.@type,
								multi: def.@multi,
								dup: def.@dup
						};
						if (Cst.ATTR_TYPE_ENUM == String(def.@type)) {
							var es: Array = new Array();
							for each (var e: Object in def.enums.enum) {
								es.push(XML(e).text().toString());
							}
							d.enums = es;
						} else if (Cst.ATTR_TYPE_NUMBER == String(def.@type)) {
							d.min = def.min.text().toString();
							d.max = def.max.text().toString();
							d.unit = def.unit.text().toString();
						}
						attrDefs.push(d);
					}
				}
				var rslt: Object = {
					id: et.@id,
						typeName: et.@name,
						superId: superId,
						typeId: -1,      // typeId is unknown before creation
						attrDefs: attrDefs
				};
				return rslt;
			} */
		]]>
	</fx:Script>
	
	<s:Label fontSize="12" top="5" left="5" text="The entity types in this model."/>
	<s:HGroup width="100%" height="100%">
		<s:VGroup width="50%" height="100%">
			<s:HGroup>
				<s:Button label="New Type" click="onNewType();"/>
				<s:Button label="New Subtype" 
						  enabled="true" enabled.EntityBegin="false" 
						  click="onNewSubtype();"/>
				<!-- The DELETE operation is not allowed. -->
			</s:HGroup>
			<s:Label fontWeight="bold" text="Current types:"/>
			<mx:Tree id="typeTree" dataProvider="{entityTypes}"
					 borderStyle="solid" width="100%" height="100%"
					 labelField="@name" itemClick="onTypeClicked(event);"
					 editable="true" showRoot="false" itemEditEnd="onTypeNameChanged(event);"/>
		</s:VGroup>
		
		<s:VGroup width="50%" height="100%" includeIn="AttrSelected, TypeSelected">
			<s:Label fontWeight="bold" text="Attributes: "/>
			
			<mx:DataGrid id="attrGrid" rowCount="6" itemClick="onAttributeClicked();"
						 width="100%">
				<mx:columns>
					<mx:DataGridColumn dataField="@name" headerText="Name" />
					<mx:DataGridColumn dataField="@type" headerText="Type" />
				</mx:columns>
			</mx:DataGrid>
			<s:Label fontWeight="bold" 
					 text.TypeSelected="Add attribute: "
					 text.AttrSelected="Edit attribute: "/>
			<common:AttributeForm id="attrForm" submit="onAttributeChanged();"/>
		</s:VGroup>
	</s:HGroup>
	
	<mx:Canvas height="30" width="100%" bottom="10">
		<s:HGroup right="10">
			<s:Button label="{RS.close}" click="onCancel();"/>
		</s:HGroup>
	</mx:Canvas>
	
</s:TitleWindow>
