1. Implement commit action.
2. Define feature fields' names and operation fields' names in protocol.
3. Complete the Response Body class.
-----------------------------
1. Implement Feature and Operation data structures.
  1.1 Make them Java Beans (default constructor and bean style getters/setters) 
  1.2 Add resource strings for operations (because they will be shared by Flex client program)
2. Implement an In-Memory data provider to hold the feature model.
3. Implement the persistent layer under the In-Memory data provider.
  (See Issue 2)
4. If we need a persistent support(e.g. return new feature's auto-generated 
   id from database) but the persistent layer hasn't done yet, we can implement
   a "persistent mock layer" first to imitate a database support.
   
ISSUE 1: Do the data providers become proxies? For example: 
   interface DataProvider {
       createFeature();
       updateFeature();
       getFeature();
       
       createUser();
       updateUser();
       getUser();
       
       createOp();
       getOp();
   } 
   
   class SomeAction {
       handleCommit(op) {
           if (op == "create_child") {
               Feature child = dataProvider.createFeature(...);
               addToResponse(child);
               response = makeResponse();
               return response;
           }
           if (op == "change_feature_name") {
               dataProvider.updateFeature(...);
               ...
           }
       }
   }

 ISSUE 2: Do we need a In-Memory Data Provider as a cache for database? Or Hibernate 
       will implement such cache for us?